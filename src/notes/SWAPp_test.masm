use.miden::note
use.miden::contracts::wallets::basic->wallet
use.miden::tx
use.miden::account
use.std::sys
use.std::crypto::hashes::native
use.std::math::u64
# CONSTANTS
# =================================================================================================

const.OFFCHAIN_NOTE=2

# ERRORS
# =================================================================================================

# SWAP script expects exactly 9 note inputs
const.ERR_SWAP_WRONG_NUMBER_OF_INPUTS=0x00020007

# SWAP script requires exactly one note asset
const.ERR_SWAP_WRONG_NUMBER_OF_ASSETS=0x00020008

# PRICE CALCULATION
# =================================================================================================

# memory addresses for calculate_tokens_a_for_b 
const.AMT_TOKENS_A=0x0064
const.AMT_TOKENS_B=0x0065
const.AMT_TOKENS_B_IN=0x0066
const.RATIO=0x0067

# factor amount
const.FACTOR=0x000186A0 # 1e5
const.MAX_U32=0x0000000100000000

# input: [tokens_a, tokens_b, tokens_b_in]
# output: [tokens_a_out]
proc.calculate_tokens_a_for_b

  mem_store.AMT_TOKENS_A # tokens_a
  mem_store.AMT_TOKENS_B # tokens_b
  mem_store.AMT_TOKENS_B_IN # tokens_b_in

  mem_load.AMT_TOKENS_B mem_load.AMT_TOKENS_A
  # => [tokens_a, tokens_b]

  gt
  if.true
    mem_load.AMT_TOKENS_B
    u32split

    push.FACTOR
    u32split
            
    exec.u64::wrapping_mul

    mem_load.AMT_TOKENS_A
    u32split

    exec.u64::div
    push.MAX_U32 mul add

    mem_store.RATIO

    mem_load.AMT_TOKENS_B_IN
    u32split

    push.FACTOR
    u32split

    exec.u64::wrapping_mul

    mem_load.RATIO
    u32split

    exec.u64::div

    push.MAX_U32 mul add          

  else
    mem_load.AMT_TOKENS_A
    u32split

    push.FACTOR
    u32split
            
    exec.u64::wrapping_mul

    mem_load.AMT_TOKENS_B
    u32split

    exec.u64::div

    mem_load.AMT_TOKENS_B_IN
    u32split

    exec.u64::wrapping_mul

    push.FACTOR
    u32split

    exec.u64::div
    push.MAX_U32 mul add          

  end
end

#! Returns the RECIPIENT for a specified SERIAL_NUM, SCRIPT_HASH, and input
#!
#! Inputs: [SERIAL_NUM, SCRIPT_HASH, INPUT_HASH]
#! Outputs: [RECIPIENT]
#!
proc.build_recipient_hash
  padw hmerge
  # => [SERIAL_NUM_HASH, SCRIPT_HASH, INPUT_HASH]

  swapw hmerge
  # => [MERGE_SCRIPT, INPUT_HASH]

  swapw hmerge
  # [RECIPIENT]
end

#! Computs the note inputs commitment for up to 16 inputs
#!
#! Inputs: [INPUTS_4, INPUTS_3, INPUTS_2, INPUTS_1]
#! Outputs: [INPUTS_HASH]
proc.get_note_inputs_commitment

  # Initialize the capacity portion of the hasher state.
  # Absorb the first 8 values into the hasher state.
  swapdw padw movupw.2 movupw.2
  # => [8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0]

  # Execute the RPO permutation.
  hperm
  # => Permuted state [R2, R1, C]

  # Drop the two capacity elements to absorb the 9th element.
  dropw dropw
  # => [R2, R1]

  # Absorb the 9th element and apply padding.
  movupw.2 movupw.2
  # => [0, 0, 0, 0, 0, 0, 0, 9, R2, R1]

  # Execute the RPO permutation.
  hperm
  # => Permuted state [R2, R1, C]

  # Convert the state to the digest.
  exec.native::state_to_digest
  # => [Digest]
end

# Swap script: adds an asset from the note into consumers account and
# creates a note consumable by note issuer containing requested ASSET.
#
# Requires that the account exposes:
#
# Inputs: [SCRIPT_ROOT]
# Outputs: []
#
# Note inputs are assumed to be as follows:
# - RECIPIENT
# - ASSET
# - TAG = [tag, 0, 0, 0]
#
# FAILS if:
# - Account does not expose miden::contracts::wallets::basic::receive_asset procedure
# - Account does not expose miden::contracts::wallets::basic::send_asset procedure
# - Account vault does not contain the requested asset
# - Adding a fungible asset would result in amount overflow, i.e., the total amount would be
#   greater than 2^63


begin

    # 1) get amount that consumer wants to sell
    # 2) calculate price ratio (todo => div with UD12x8 or UD14x6)
    # => ratio = token_b / token_a

    # 3) calculate token a amount out to consumer
    # => token_a_out = balance_b * ratio

    # 4) calculate token b amount to creator
    
    # 5) calculate token a remaining for new SWAPp note
    # => token_a_remaining = token_a - token_a_out 

    # 6) calculate updated token b requested amount (input hash)
    # => token_b_requested_remaining = token_a_remaining * ratio

    # 7) verify price ratio is constant within some margin (precision loss depends on fixed point lib precision)
    # => assert_eq(token_b_requested_remaining / token_a_remaining , token_b / token_a)
 
    # store SWAPp script hash to mem addr 4 & drop
    mem_storew.4 dropw
    # => []

    # store asset into memory at address 3
    exec.note::get_assets assert.err=ERR_SWAP_WRONG_NUMBER_OF_ASSETS
    # => [ptr]

    # load the asset and add it to the account
    mem_loadw
    # => [OFFERED_ASSET]

    # store token_a_id to mem addr 6
    dup mem_store.6 mem_storew.5
    # => []

    # store token_a_AMT to mem addr 8
    drop drop drop mem_store.8
    # => []

    # store note inputs into memory starting at address 0
    push.0 exec.note::get_inputs
    # => [num_inputs, inputs_ptr]

    # make sure the number of inputs is 9
    eq.9 assert.err=ERR_SWAP_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]

    drop padw mem_loadw
    debug.stack


    mem_loadw.1
    # => [REQUESTED_ASSET]

    debug.stack

    # store token_b_id to memory addr 7
    dup mem_store.7
    
    # store token_b_AMT to mem addr 9
    drop drop drop mem_store.9

    # TODO use note args to get amount consumer wants to sell
    # get token b amt out
    mem_load.7 call.account::get_balance
    # => [token_b_AMT_IN]

    # store token_b_AMT_IN @ mem addr 10
    dup mem_store.10
    # => [token_b_AMT_IN]

    mem_load.9 mem_load.8
    # => [token_a_AMT, token_b_AMT, token_b_AMT_IN]

    exec.calculate_tokens_a_for_b
    # [token_a_AMT_out]

    # store token_a_AMT_out @ mem addr 11
    dup mem_store.11

    mem_load.8
    # => [token_a_AMT, token_a_AMT_out]

    gte

    # if amount_a < amount_out
    # amount_out = amount_a
    if.true
      mem_load.8
    else
      mem_load.11
    end

    # 1) send token B amt in to creator
    # 2) send token A out amt to consumer
    # 3) create SWAPp' and calculate token_a & token_b
    # 4) add token_a' and token_b' to SWAPp' 

    # 1) send token B amt to creator
    mem_loadw.0 push.2 mem_load.2 mem_load.10 push.0.0 mem_load.7
    # => [requested_token_id, 0, 0, token_b_AMT_IN, tag, note_type, RECIPIENT_P2ID]

    push.101
    debug.stack
    drop

    call.wallet::send_asset dropw
    # => []

    # 2) send token A out amt to consumer
    mem_load.11 push.0.0 mem_load.6
    # => [token_a_AMT_OUT, 0, 0, token_a_id]

    call.wallet::receive_asset
    # => []

    # 3) create SWAPp' and calculate token_a' & token_b'
    padw mem_loadw.0
    # => [PAYBACK_RECIPIENT]

    mem_load.9 mem_load.10 sub
    # => [token_b_AMT', PAYBACK_RECIPIENT]

    push.0.0 mem_load.7
    # [REQUESTED_ASSET_REMAINING, PAYBACK_RECIPIENT]

    mem_load.2
    # => [payback_tag, ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

    push.0.0.0.0.0.0.0
    # => [0,0,0,0,0,0,0, payback_tag, ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

    push.102
    debug.stack
    drop

    exec.get_note_inputs_commitment
    # => [INPUTS_HASH]

    push.103
    debug.stack
    drop

    padw mem_loadw.4
    # => [SCRIPT_HASH, INPUTS_HASH]

    push.1.2.3.4
    # => [SERIAL_NUM, SCRIPT_HASH, INPUTS_HASH]

    push.444
    debug.stack
    drop

    exec.build_recipient_hash 
    # => [RECIPIENT_SWAPP]

    push.105
    debug.stack
    drop

    push.2 mem_load.2
    # => [payback_tag, note_type, RECIPIENT_SWAPP]

    push.111
    debug.stack
    drop

    call.tx::create_note
    # => [swapp_ptr]

    mem_load.8 mem_load.11 sub push.0.0 mem_load.6
    # => [OFFERED_ASSET_REMAINING, swapp_ptr]

    movup.4
    # => [swapp_ptr, OFFERED_ASSET_REMAINING]

    push.222
    debug.stack
    drop

    call.tx::add_asset_to_note
    # => [swapp_ptr]

    push.1
    call.account::incr_nonce

    # clean stack
    exec.sys::truncate_stack
end
