use.miden::note
use.miden::contracts::wallets::basic->wallet
use.miden::tx
use.miden::account
use.std::sys
use.std::crypto::hashes::native
# CONSTANTS
# =================================================================================================

const.OFFCHAIN_NOTE=2

# ERRORS
# =================================================================================================

# SWAP script expects exactly 9 note inputs
const.ERR_SWAP_WRONG_NUMBER_OF_INPUTS=0x00020007

# SWAP script requires exactly one note asset
const.ERR_SWAP_WRONG_NUMBER_OF_ASSETS=0x00020008

#! Returns the RECIPIENT for a specified SERIAL_NUM, SCRIPT_HASH, and input
#!
#! Inputs: [SERIAL_NUM, SCRIPT_HASH, input]
#! Outputs: [RECIPIENT]
#!
#! Only allows a single input currently
proc.build_recipient_hash
  padw hmerge
  # => [SERIAL_NUM_HASH, SCRIPT_HASH, INPUT_HASH]

  # merge SERIAL_NUM_HASH and SCRIPT_HASH
  swapw hmerge
  # => [SERIAL_SCRIPT_HASH, INPUT_HASH]

  # compute the INPUT_HASH. Note: only one input is allowed
  hmerge
  # => [INPUT_HASH, SERIAL_SCRIPT_HASH]

  hmerge
  # [RECIPIENT]
end

#! Computs the note inputs commitment for up to 16 inputs
#!
#! Inputs: [INPUTS_4, INPUTS_3, INPUTS_2, INPUTS_1]
#! Outputs: [INPUTS_HASH]
proc.get_note_inputs_commitment

  # Initialize the capacity portion of the hasher state.
  # Absorb the first 8 values into the hasher state.
  swapdw padw movupw.2 movupw.2
  # => [8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0]

  # Execute the RPO permutation.
  hperm
  # => Permuted state [R2, R1, C]

  # Drop the two capacity elements to absorb the 9th element.
  dropw dropw
  # => [R2, R1]

  # Absorb the 9th element and apply padding.
  movupw.2 movupw.2
  # => [0, 0, 0, 0, 0, 0, 0, 9, R2, R1]

  # Execute the RPO permutation.
  hperm
  # => Permuted state [R2, R1, C]

  # Convert the state to the digest.
  exec.native::state_to_digest
  # => [Digest]
end

# Swap script: adds an asset from the note into consumers account and
# creates a note consumable by note issuer containing requested ASSET.
#
# Requires that the account exposes:
#
# Inputs: [SCRIPT_ROOT]
# Outputs: []
#
# Note inputs are assumed to be as follows:
# - RECIPIENT
# - ASSET
# - TAG = [tag, 0, 0, 0]
#
# FAILS if:
# - Account does not expose miden::contracts::wallets::basic::receive_asset procedure
# - Account does not expose miden::contracts::wallets::basic::send_asset procedure
# - Account vault does not contain the requested asset
# - Adding a fungible asset would result in amount overflow, i.e., the total amount would be
#   greater than 2^63

# Memory Layout:
# ├── 0x00000000: [PAYBACK_RECIPIENT]
# ├── 0x00000001: [REQUESTED_ASSET]
# ├── 0x00000002: [payback_tag]
# ├── 0x00000003: [?]
# ├── 0x00000004: [?]
# ├── 0x00000005: [SWAPP_SCRIPT_HASH]
# ├── 0x00000006: [token_for_sale_id]
# ├── 0x00000007: [requested_token_id]
# ├── 0x00000008: [initial_balance_token_a_of_note]
# ├── 0x00000009: [initial_balance_token_a_of_wallet]
# ├── 0x0000000a: [requested_balance_token_b_note]
# ├── 0x0000000b: [initial_balance_of_token_b_of_wallet]
# ├── 0x0000000c: [ASSET_remainder_for_new_SWAPp_note_token_a]
# └── 0x0000000d: [new_SWAPp_ptr]
begin
    # store SWAPp script hash to mem addr 5 & drop
    mem_storew.5 dropw
    # => []

    # store asset into memory at address 3
    push.3 exec.note::get_assets assert.err=ERR_SWAP_WRONG_NUMBER_OF_ASSETS
    # => [ptr]

    # load the asset and add it to the account
    mem_loadw
    # => [REQUESTED_ASSET]

    # store token_a_id to memory addr 6
    dup mem_store.6
    # => [REQUESTED_ASSET]
    
    # get token_a balance user wallet save @ mem addr 9
    mem_load.6 call.account::get_balance mem_store.9
    # => [REQUESTED_ASSET] 

    # save token_a balance of note @ mem addr 8
    swap.3 dup mem_store.8 swap.3
    # => [REQUESTED_ASSET] 

    call.wallet::receive_asset dropw
    # => []

    # store note inputs into memory starting at address 0
    push.0 exec.note::get_inputs
    # => [num_inputs, inputs_ptr]

    # make sure the number of inputs is 9
    eq.9 assert.err=ERR_SWAP_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]

    # load recipient
    drop padw mem_loadw
    # => [RECIPIENT_P2ID]

    padw mem_loadw.1
    # => [ASSET, RECIPIENT_P2ID]

    padw mem_loadw.2
    # => [0, 0, 0, tag, ASSET, RECIPIENT_P2ID]

    drop drop drop movdn.4
    # => [ASSET, tag, RECIPIENT_P2ID]

    push.OFFCHAIN_NOTE movdn.5
    # => [ASSET, tag, note_type, RECIPIENT_P2ID]
    
    # save requested token id to memory @ mem addr 7
    dup mem_store.7
    # => [ASSET, tag, note_type, RECIPIENT_P2ID]

    # save requested token amount to memory @ mem addr 10
    swap.3 mem_store.10 push.0 swap.3
    # => [requested asset id, 0, 0, 0, tag, note_type, RECIPIENT_P2ID]

    # call into account to get max bal
    call.account::get_balance
    # => [requested asset balance user wallet, 0, 0, 0, tag, note_type, RECIPIENT_P2ID]
    
    # store wallet balance requested token @ mem addr 11
    mem_store.11
    # =>  [0, 0, 0, tag, note_type, RECIPIENT_P2ID]

    # load requested amount token_b and initial balance of token_b of WALLET
    mem_load.10 mem_load.11
    # => [wallet_balance, requested_amount, 0, 0, 0, tag, note_type, RECIPIENT_P2ID]

    # check if requested amount is gte to wallet balance
    gte
    # => [isRequestedAmountGTEwalletBalance, 0, 0, 0, tag, note_type, RECIPIENT_P2ID] 

    # Call send_asset with wallet balance
    # output new SWAPp note
    if.true
      # => [0, 0, 0, tag, note_type, RECIPIENT_P2ID] 

      # load wallet balance
      mem_load.11 swap.3 drop
      # => [0, 0, wallet balance, tag, note_type, RECIPIENT_P2ID] 

      # load requested token id
      mem_load.7
      # => [requested_token_id, 0, 0, wallet balance, tag, note_type, RECIPIENT_P2ID]

      push.102
      debug.stack
      drop 

      # create a note using inputs
      call.wallet::send_asset
      # => [ptr, ZERO, ZERO, 0]

      dropw
      # => []

      ### Building Inputs Hash Commitment

      # get PAYBACK_RECIPIENT
      padw mem_loadw.0
      # => [PAYBACK_RECIPIENT] 

      # load requested amt & initial balance wallet token b
      mem_load.10 mem_load.11
      # => [requested_amt, balance_requested_wallet, PAYBACK_RECIPIENT]
      
      # compute remainder 
      sub
      # => [amt_requested_remaining, PAYBACK_RECIPIENT]

      push.0.0
      # => [0,0, amt_requested_remaining, PAYBACK_RECIPIENT]

      # get requested asset_id
      mem_load.7
      # => [ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

      push.111
      debug.stack
      drop

      # store ASSET out to memory addr 12
      # dupw
      mem_storew.12
      # => [ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

      # get payback_tag
      mem_load.2 
      # => [payback_tag, ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

      # padw padw drop
      push.0.0.0.0.0.0.0
      # => [0,0,0,0,0,0,0, payback_tag, ASSET_REQUESTED_REMAINING, PAYBACK_RECIPIENT]

      exec.get_note_inputs_commitment
      # => [INPUTS_HASH]

      # push SWAPp note SCRIPT_HASH 
      mem_loadw.5
      # => [SCRIPT_HASH]

      # Serial Number
      push.1.2.3.4
      # => [SERIAL_NUM, SCRIPT_HASH]

      exec.build_recipient_hash 
      # => [RECIPIENT_SWAPP]

      # note type
      push.2
      # => [note_type, RECIPIENT_SWAPP]

      # tag
      mem_load.2
      # => [tag, note_type, RECIPIENT_SWAPP]



      call.tx::create_note
      # => [note_ptr]

      # store ptr to mem addr 3
      mem_store.13
      # => []

      # load ASSET_REQUESTED_REMAINING
      mem_loadw.12

      # load note ptr
      mem_load.13
      # => [swapp_ptr, ASSET_REMAINING]

      push.111
      debug.stack
      drop

      call.tx::add_asset_to_note
      # => [swapp_ptr]

      # remove asset remaining
      mem_loadw.12 call.account::remove_asset dropw
      # => []
      debug.mem

    # call send_asset with requested amount
    # do not ouput new SWAPp note
    else
      # @dev in progress...
      push.1111
      debug.stack
      drop 

      call.wallet::send_asset

    end

    push.1
    call.account::incr_nonce

    # clean stack
    exec.sys::truncate_stack
end
