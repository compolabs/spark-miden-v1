use.miden::note
use.miden::contracts::wallets::basic->wallet
use.miden::tx
use.miden::account
use.std::sys
use.std::crypto::hashes::native
use.std::math::u64

#! Computs the note inputs commitment for up to 16 inputs
#!
#! Inputs: [INPUTS_4, INPUTS_3, INPUTS_2, INPUTS_1]
#! Outputs: [INPUTS_HASH]
proc.hash_secret

    # Initialize the capacity portion of the hasher state.
    # Absorb the first 8 values into the hasher state.
    swapdw padw movupw.2 movupw.2
    # => [8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0]

    # Execute the RPO permutation.
    hperm
    # => Permuted state [R2, R1, C]

    # Drop the two capacity elements to absorb the 9th element.
    dropw dropw
    # => [R2, R1]

    # Absorb the 9th element and apply padding.
    movupw.2 movupw.2
    # => [0, 0, 0, 0, 0, 0, 0, 9, R2, R1]

    # Execute the RPO permutation.
    hperm
    # => Permuted state [R2, R1, C]

    # Convert the state to the digest.
    exec.native::state_to_digest
    # => [Digest]
end

begin
    dropw
    # => [INPUT_SECRET]

    # store secret @ mem address 5
    mem_storew.5
    dropw
    # => []

    # @dev hashing 8 inputs
    # [INPUT_SECRET, 0, 0, 0, 0]
    push.8.5
    exec.note::compute_inputs_hash
    # => [INPUT_SECRET_HASH]

    push.0 exec.note::get_inputs drop drop
    # => [INPUT_SECRET_HASH]

    # get secret hash
    padw mem_loadw.3
    # => [SECRET_HASH, INPUT_SECRET_HASH]

    # if this passes, allow asset withdrawl
    assert_eqw

    push.0 exec.note::get_assets
    mem_loadw.0
    call.wallet::receive_asset
    exec.sys::truncate_stack
end
